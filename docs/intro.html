<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>1&nbsp; Introdução – Matemática para Ciência da Computação</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./summary.html" rel="next">
<link href="./index.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./intro.html"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Matemática para Ciência da Computação</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Início</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#proposições" id="toc-proposições" class="nav-link active" data-scroll-target="#proposições"><span class="header-section-number">1.1</span> Proposições</a></li>
  <li><a href="#predicados" id="toc-predicados" class="nav-link" data-scroll-target="#predicados"><span class="header-section-number">1.2</span> Predicados</a></li>
  <li><a href="#método-axiomático" id="toc-método-axiomático" class="nav-link" data-scroll-target="#método-axiomático"><span class="header-section-number">1.3</span> Método Axiomático</a>
  <ul class="collapse">
  <li><a href="#deduções-lógicas" id="toc-deduções-lógicas" class="nav-link" data-scroll-target="#deduções-lógicas"><span class="header-section-number">1.3.1</span> Deduções Lógicas</a></li>
  <li><a href="#padrões-de-prova" id="toc-padrões-de-prova" class="nav-link" data-scroll-target="#padrões-de-prova"><span class="header-section-number">1.3.2</span> Padrões de Prova</a></li>
  </ul></li>
  <li><a href="#provando-uma-implicação" id="toc-provando-uma-implicação" class="nav-link" data-scroll-target="#provando-uma-implicação"><span class="header-section-number">1.4</span> Provando uma Implicação</a>
  <ul class="collapse">
  <li><a href="#método-1" id="toc-método-1" class="nav-link" data-scroll-target="#método-1"><span class="header-section-number">1.4.1</span> Método #1</a></li>
  <li><a href="#método-2" id="toc-método-2" class="nav-link" data-scroll-target="#método-2"><span class="header-section-number">1.4.2</span> Método #2</a></li>
  </ul></li>
  <li><a href="#provando-se-somente-se" id="toc-provando-se-somente-se" class="nav-link" data-scroll-target="#provando-se-somente-se"><span class="header-section-number">1.5</span> Provando “se somente se””</a>
  <ul class="collapse">
  <li><a href="#método-1-prove-que-cada-declaração-implica-na-outra" id="toc-método-1-prove-que-cada-declaração-implica-na-outra" class="nav-link" data-scroll-target="#método-1-prove-que-cada-declaração-implica-na-outra"><span class="header-section-number">1.5.1</span> Método #1: Prove que Cada Declaração Implica na Outra</a></li>
  <li><a href="#método-2-construa-uma-cadeia-de-sse" id="toc-método-2-construa-uma-cadeia-de-sse" class="nav-link" data-scroll-target="#método-2-construa-uma-cadeia-de-sse"><span class="header-section-number">1.5.2</span> Método #2: Construa uma Cadeia de SSE</a></li>
  <li><a href="#exemplo" id="toc-exemplo" class="nav-link" data-scroll-target="#exemplo"><span class="header-section-number">1.5.3</span> Exemplo</a></li>
  </ul></li>
  <li><a href="#modus-ponens" id="toc-modus-ponens" class="nav-link" data-scroll-target="#modus-ponens"><span class="header-section-number">1.6</span> Modus ponens</a>
  <ul class="collapse">
  <li><a href="#um-erro-lógico-comum." id="toc-um-erro-lógico-comum." class="nav-link" data-scroll-target="#um-erro-lógico-comum."><span class="header-section-number">1.6.1</span> Um erro lógico comum.</a></li>
  <li><a href="#encadeando-implicações" id="toc-encadeando-implicações" class="nav-link" data-scroll-target="#encadeando-implicações"><span class="header-section-number">1.6.2</span> Encadeando implicações</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introdução</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div style="text-align: justify">
<p>Material inteiramente baseado em Albert R Meyer et al.&nbsp;Mathematics for computer science. Chapter, 13:253–272, 2002. Disponível em https://courses.csail.mit.edu/6.042/spring18/mcs.pdf</p>
</div>
<section id="proposições" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="proposições"><span class="header-section-number">1.1</span> Proposições</h2>
<div style="text-align: justify">
<div id="def-line" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.1 (Proposição)</strong></span> Uma proposição é uma afirmação (comunicação) que ou é verdadeira ou falsa.</p>
<p>Por exemplo, as duas afirmações a seguir são proposições. A primeira é verdadeira enquanto a segunda é falsa.</p>
</div>
<div id="prp-line1" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1.1</strong></span> <span class="math inline">\(2 + 3 = 5\)</span></p>
</div>
<div id="prp-line2" class="theorem proposition">
<p><span class="theorem-title"><strong>Proposition 1.2</strong></span> <span class="math inline">\(1 + 1 = 3\)</span></p>
</div>
<p>Ser falso ou verdadeiro parece não limitar muito nossas possibilidades, mas exclui alguns casos com o “Es tu Romeo?” e “Me dê um SS!”. Também exclui afirmações em que a verdade varia de acordo com as circunstâncias como, “São 17 horas” ou “as ações vão subir amanhã”.</p>
<p>Infelizmente, nem sempre é trivial decidir se uma dada proposição é verdadeira ou falsa:</p>
<div id="exm-line1" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.1 (Afirmação)</strong></span> <em>Para todo inteiro não-negativo <span class="math inline">\(n\)</span> o valor de <span class="math inline">\(n^2 + n + 41\)</span> é um número primo</em></p>
<p><span class="math display">\[
P(n) = primo
\]</span></p>
</div>
<p>Um número primo é um inteiro maior que 1 que não é divisível por nenhum outro número inteiro maior que 1, a não ser ele mesmo. Por exemplo, 2, 3, 5, 7, 11 são os primeiros cinco números primos. Vamos tentar uma experimentação numérica para verifcar essa proposição. Considere:</p>
<p><span class="math display">\[
p(n) ::= n^2 + n + 41
\]</span></p>
<p>Começamos com <span class="math inline">\(p(0) = 41\)</span>, que é primo. Então,</p>
<p><span class="math display">\[
p(1) = 43, p(2) = 47, p(3) = 53, \cdots , p(20) = 461
\]</span></p>
<p>são todos primos. Podemos seguir validando a proposição até <span class="math inline">\(n = 39\)</span> e confirmar que <span class="math inline">\(p(39) = 1601\)</span> é primo. Porém, <span class="math inline">\(p(40) = 41 \times 41\)</span>, que não é primo. Portanto a proposição é falsa, uma vez que não é verdadeiro que <span class="math inline">\(p(n)\)</span> seja primo para <em>todos</em> os inteiros não-negativos <span class="math inline">\(n\)</span>. Esse exemplo evidencia um ponto importante que, em geral, não é possível validar uma afirmação sobre um conjunto infinito checando uma amostra finita de seus elementos, não importa o quão grande sera a amostra.</p>
<p>Tais proposições a respeito de <em>todos</em> ou <em>qualquer</em> número ou itens de algum tipo são bastante comuns e possuem uma notação especial. Com essa notação, a proposição acima seria:</p>
<div id="exm-line2" class="theorem example">
<p><span class="theorem-title"><strong>Example 1.2 (Proposição)</strong></span> <span class="math inline">\(\quad \forall \quad n \in \mathbb{N}, \quad p(n)\)</span> é primo</p>
</div>
<p>Em que o símbolo <span class="math inline">\(\forall\)</span> significa , o símbolo <span class="math inline">\(\mathbb{N}\)</span> representa o conjunto de inteiros não-negativos e <span class="math inline">\(\in\)</span> significa “pertence”.</p>
</div>
</section>
<section id="predicados" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="predicados"><span class="header-section-number">1.2</span> Predicados</h2>
<div style="text-align: justify">
<p>Um predicado pode ser entendido como uma proposição cuja verdade depende do valor de uma ou mais variáveis. Portanto, “n é um quadrado perfeito” descreve um predicado, uma vez que você não pode dizer se é verdadeiro ou falso até saber qual é o valor da variável n.&nbsp;Uma vez que você sabe, por exemplo, que n é igual a 4, o predicado se torna a proposição verdadeira “4 é um quadrado perfeito”.</p>
<p>Lembre-se, nada diz que a proposição precisa ser verdadeira: se o valor de n fosse 5, você teria a proposição falsa “5 é um quadrado perfeito.” Assim como outras proposições, os predicados geralmente são nomeados com uma letra. Além disso, uma notação semelhante à de uma função é usada para denotar um predicado fornecido com valores variáveis específicos. Por exemplo, podemos usar o nome “P” para o predicado abaixo.</p>
<p><span class="math display">\[
P(n) ::= \textrm{``} n \textrm{ é um quadrado perfeito",}
\]</span></p>
<p>e repita as observações acima afirmando que P(4) é verdadeiro, e P(5) é falso. Essa notação para predicados é confusamente similar à notação de funções ordinárias. Se P é um predicado, então P(n) é verdadeiro ou falso, dependendo do valor de n. Por outro lado, se p é uma função ordinária, como <span class="math inline">\(n^2 +1\)</span>, então p(n) é uma quantidade numérica. Não confunda esses dois!</p>
</div>
</section>
<section id="método-axiomático" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="método-axiomático"><span class="header-section-number">1.3</span> Método Axiomático</h2>
<div style="text-align: justify">
<p>O procedimento padrão para estabelecer a verdade na matemática foi inventado por Euclides, um matemático que trabalhava em Alexandria, Egito, por volta de 300 a.C. Sua ideia era começar com cinco suposições sobre geometria, que pareciam inegáveis com base na experiência direta. (Por exemplo, “Existe um segmento de linha reta entre cada par de pontos”.) Proposições como essas, que são simplesmente aceitas como verdadeiras, são chamadas de axiomas.</p>
<p>A partir desses axiomas, Euclides estabeleceu a verdade de muitas outras proposições fornecendo “provas”. Uma prova é uma sequência de deduções lógicas a partir de axiomas e declarações previamente provadas que conclui com a proposição em questão.</p>
<p>Existem vários termos comuns para uma proposição que foi provada. Os diferentes termos sugerem o papel da proposição dentro de um corpo de trabalho maior.</p>
<ul>
<li>Proposições verdadeiras importantes são chamadas de <em>teoremas</em>.</li>
<li>Um <em>lema</em> é uma proposição preliminar útil para provar proposições posteriores.</li>
<li>Um <em>corolário</em> é uma proposição que segue em apenas alguns passos lógicos de um teorema.</li>
</ul>
<p>Essas definições não são precisas. Na verdade, às vezes um bom lema acaba se tornando muito mais importante do que o teorema que ele originalmente pretendia provar.</p>
<p>A abordagem de axiomas e provas de Euclides, agora chamada de método axiomático, continua sendo a base da matemática até hoje. De fato, apenas um pequeno conjunto de axiomas, chamados axiomas de Zermelo-Fraenkel com a escolha (ZFC), junto com algumas regras de dedução lógica, parecem ser suficientes para derivar essencialmente toda a matemática.</p>
</div>
<section id="deduções-lógicas" class="level3" data-number="1.3.1">
<h3 data-number="1.3.1" class="anchored" data-anchor-id="deduções-lógicas"><span class="header-section-number">1.3.1</span> Deduções Lógicas</h3>
<div style="text-align: justify">
<p>Deduções lógicas, ou <strong>regras de inferência</strong>, são usadas para provar novas proposições utilizando aquelas já previamente provadas.</p>
<p>Uma regra de inferência fundamental é o <strong>modus ponens</strong>. Essa regra diz que uma prova de (P) junto com uma prova de que (P Q) é uma prova de (Q).</p>
<p>As regras de inferência são, às vezes, escritas em uma notação peculiar. Por exemplo, o <strong>modus ponens</strong> é escrito assim:</p>
<p><strong>Regra.</strong></p>
<p><span class="math display">\[
\frac{P, \, P \text{ \small{IMPLICA} } Q}{Q}
\]</span></p>
<p>Quando as declarações acima da linha, chamadas de <strong>antecedentes</strong>, são provadas, podemos considerar que a declaração abaixo da linha, chamada de <strong>conclusão</strong> ou <strong>consequente</strong>, também está provada.</p>
<p>Um requisito fundamental de uma regra de inferência é que ela deve ser <strong>sólida</strong>: uma atribuição de valores de verdade às letras <span class="math inline">\((P), (Q), . . .\)</span> que torna todos os antecedentes verdadeiros deve também tornar o consequente verdadeiro. Assim, se começarmos com axiomas verdadeiros e aplicarmos regras de inferência sólidas, tudo o que provamos também será verdadeiro.</p>
<p>Existem muitas outras regras de inferência naturais e sólidas, por exemplo:</p>
<p><strong>Regra.</strong></p>
<p><span class="math display">\[
\frac{P \text{ \small{IMPLICA} } Q, \, Q \text{ \small{IMPLICA} } R}{P \text{ \small{IMPLICA} } R}
\]</span></p>
<p><strong>Regra.</strong></p>
<p><span class="math display">\[
\frac{\text{\small{NÃO}} (P) \text{ \small{IMPLICA} } \text{\small{NÃO}} (Q)}{Q \text{ \small{IMPLICA} } P}
\]</span></p>
<p>Por outro lado,</p>
<p><strong>Não-Regra.</strong></p>
<p><span class="math display">\[
\frac{\text{\small{NÃO}} (P) \text{ \small{IMPLICA} } \text{\small{NÃO}} (Q)}{P \text{ \small{IMPLICA} } Q}
\]</span></p>
<p>não é sólida: se <span class="math inline">\((P)\)</span> for atribuído como verdadeiro (T) e <span class="math inline">\((Q)\)</span> como falso (F), então o antecedente é verdadeiro e o consequente não é.</p>
<p>Assim como com axiomas, não seremos muito formais sobre o conjunto de regras de inferência legais. Cada passo em uma prova deve ser claro e “lógico”; em particular, você deve indicar quais fatos previamente provados são usados para derivar cada nova conclusão.</p>
</div>
</section>
<section id="padrões-de-prova" class="level3" data-number="1.3.2">
<h3 data-number="1.3.2" class="anchored" data-anchor-id="padrões-de-prova"><span class="header-section-number">1.3.2</span> Padrões de Prova</h3>
<div style="text-align: justify">
<p>Em princípio, uma prova pode ser qualquer sequência de deduções lógicas a partir de axiomas e declarações previamente provadas que conclui com a proposição em questão. Essa liberdade na construção de uma prova pode parecer avassaladora no início. Como você começa uma prova?</p>
<p>Aqui está a boa notícia: muitas provas seguem um, de um alguns templates padrão. Cada prova tem seus próprios detalhes, é claro, mas esses templates pelo menos fornecem um esboço para você preencher. Vamos passar por vários desses padrões, apontando a ideia básica, os erros comuns e dando alguns exemplos. Muitos desses templates se encaixam; um pode lhe dar um esboço de alto nível, enquanto outros ajudam em um nível maior de detalhe.</p>
<p>As receitas abaixo são muito específicas às vezes, dizendo exatamente quais palavras escrever em seu papel. Você certamente é livre para expressar as coisas do seu jeito; estamos apenas lhe dando algo que você poderia dizer para que nunca fique completamente perdido.</p>
</div>
</section>
</section>
<section id="provando-uma-implicação" class="level2" data-number="1.4">
<h2 data-number="1.4" class="anchored" data-anchor-id="provando-uma-implicação"><span class="header-section-number">1.4</span> Provando uma Implicação</h2>
<div style="text-align: justify">
<p>Proposições da forma “Se <span class="math inline">\((P)\)</span>, então <span class="math inline">\((Q)\)</span>” são chamadas de <strong>implicações</strong>. Essa implicação é frequentemente reformulada como “<span class="math inline">\((P \text{ \small{IMPLICA} } Q)\)</span>.”</p>
<p>Aqui estão alguns exemplos:</p>
<ul>
<li>(Fórmula Quadrática) Se <span class="math inline">\(ax^2 + bx + c = 0\)</span> e <span class="math inline">\(a \neq 0\)</span>, então</li>
</ul>
<p><span class="math display">\[
x = \left(-b \pm \sqrt{b^2 - 4ac}\right) / 2a.
\]</span></p>
<ul>
<li><p>(Conjectura de Goldbach reformulada) Se <span class="math inline">\((n)\)</span> é um número inteiro par maior que 2, então <span class="math inline">\((n)\)</span> é a soma de dois números primos.</p></li>
<li><p>Se <span class="math inline">\((0 \leq x \leq 2)\)</span>, então <span class="math inline">\((-x^3 + 4x + 1 &gt; 0)\)</span>.</p></li>
</ul>
<p>Existem alguns métodos padrão para provar uma implicação.</p>
</div>
<section id="método-1" class="level3" data-number="1.4.1">
<h3 data-number="1.4.1" class="anchored" data-anchor-id="método-1"><span class="header-section-number">1.4.1</span> Método #1</h3>
<div style="text-align: justify">
<p>Para provar que <span class="math inline">\((P \text{ \small{IMPLICA} } Q)\)</span>:</p>
<ol type="1">
<li>Escreva: “Assuma <span class="math inline">\((P)\)</span>.”</li>
<li>Mostre que <span class="math inline">\((Q)\)</span> segue logicamente.</li>
</ol>
<p><strong>Exemplo</strong></p>
<div id="thm-1" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1.1</strong></span> Se <span class="math inline">\(\quad (0 \leq x \leq 2),\quad\)</span> então <span class="math inline">\(\quad (-x^3 + 4x + 1 &gt; 0)\)</span></p>
</div>
<p>Antes de escrevermos uma prova deste teorema, temos que fazer alguns rascunhos para entender por que ele é verdadeiro.</p>
<p>A desigualdade certamente é válida para <span class="math inline">\((x = 0)\)</span> então o lado esquerdo é igual a 1, e 1 &gt; 0. À medida que <span class="math inline">\((x)\)</span> cresce, o termo <span class="math inline">\((4x)\)</span> (que é positivo) inicialmente parece ter maior magnitude do que <span class="math inline">\((x^3)\)</span> (que é negativo). Por exemplo, quando <span class="math inline">\((x = 1)\)</span> temos <span class="math inline">\((4x = 4)\)</span> mas <span class="math inline">\((x^3 = -1)\)</span> Na verdade, parece que <span class="math inline">\((x^3)\)</span> não começa a dominar até <span class="math inline">\((x &gt; 2)\)</span> Portanto, parece que a parte <span class="math inline">\((x^3 + 4x)\)</span> deve ser não negativa para todo <span class="math inline">\((x)\)</span> entre 0 e 2, o que implicaria que <span class="math inline">\((x^3 + 4x + 1)\)</span> é positivo.</p>
<p>Até agora, tudo bem. Mas ainda precisamos substituir todas essas expressões como “parece que” por argumentos sólidos e lógicos. Podemos obter uma melhor compreensão da parte crítica <span class="math inline">\((x^3 + 4x)\)</span> ao fatorá-la, o que não é muito difícil:</p>
<p><span class="math display">\[
-x^3 + 4x = x(2 - x)(2 + x)
\]</span></p>
<p>Aha! Para <span class="math inline">\((x)\)</span> entre 0 e 2, todos os termos no lado direito são não negativos. E o produto de termos não negativos também é não negativo. Vamos organizar essa avalanche de observações em uma prova limpa.</p>
<p><strong>Prova.</strong> Assuma <span class="math inline">\((0 \leq x \leq 2)\)</span>. Então <span class="math inline">\((x)\)</span>, <span class="math inline">\((2 - x)\)</span> e <span class="math inline">\((2 + x)\)</span> são todos não negativos. Portanto, o produto desses termos também é não negativo. Adicionando 1 a esse produto obtemos um número positivo, assim:</p>
</div>
<p><span class="math display">\[
x(2 - x)(2 + x) + 1 &gt; 0
\]</span></p>
<p>Multiplicando no lado esquerdo prova que</p>
<p><span class="math display">\[
-x^3 + 4x + 1 &gt; 0
\]</span></p>
<p>como afirmado. <span class="math inline">\(\hspace{330pt} \blacksquare\)</span></p>
<div style="text-align: justify">
<p>Existem alguns pontos aqui que se aplicam a todas as provas:</p>
<ul>
<li><p>Você frequentemente precisará fazer alguns rascunhos enquanto tenta descobrir os passos lógicos de uma prova. Seus rascunhos podem ser tão desorganizados quanto você quiser — cheios de becos sem saída, diagramas estranhos, palavras obscenas, seja o que for. Mas mantenha seus rascunhos separados da sua prova final, que deve ser clara e concisa.</p></li>
<li><p>As provas normalmente começam com a palavra “Prova” e terminam com algum tipo de delimitador como <span class="math inline">\(\blacksquare\)</span> ou “QED.” O único propósito dessas convenções é esclarecer onde as provas começam e terminam.</p></li>
</ul>
</div>
</section>
<section id="método-2" class="level3" data-number="1.4.2">
<h3 data-number="1.4.2" class="anchored" data-anchor-id="método-2"><span class="header-section-number">1.4.2</span> Método #2</h3>
<div style="text-align: justify">
<p>Uma implicação “<span class="math inline">\(P \text{ \small{IMPLICA} } Q\)</span>” é logicamente equivalente à sua contrapositiva <span class="math inline">\(\text{\small{NÃO}}(Q) \text{ \small{IMPLICA} } \text{\small{NÃO}}(P)\)</span>:<br>
Provar uma é tão bom quanto provar a outra, e às vezes provar a contrapositiva é mais fácil do que provar a declaração original. Se for o caso, você pode proceder da seguinte forma:</p>
<ol type="1">
<li>Escreva: “Vamos provar a contrapositiva:” e, em seguida, declare a contrapositiva.</li>
<li>Prossiga como no Método #1.</li>
</ol>
<p><strong>Exemplo</strong><br>
<strong>Teorema</strong> Se <span class="math inline">\(r\)</span> é irracional, então <span class="math inline">\(\sqrt{r}\)</span> é irracional.</p>
<p>Um número é racional quando é igual a uma fração de inteiros — ou seja, se é igual a <span class="math inline">\(m/n\)</span> para alguns inteiros <span class="math inline">\(m\)</span> e <span class="math inline">\(n\)</span>. Se não for racional, então é chamado de irracional. Portanto, devemos mostrar que se <span class="math inline">\(r\)</span>$ não é uma razão de inteiros, então <span class="math inline">\(\sqrt{r}\)</span> também não é uma razão de inteiros. Isso é bem complicado! Podemos eliminar ambas as negações e simplificar a prova usando a contrapositiva em vez disso.</p>
<p><strong>Prova.</strong> Vamos provar a contrapositiva: se <span class="math inline">\(\sqrt{r}\)</span> é racional, então <span class="math inline">\(r\)</span> é racional.<br>
Assuma que <span class="math inline">\(\sqrt{r}\)</span> é racional. Então, existem inteiros <span class="math inline">\(m\)</span> e <span class="math inline">\(n\)</span> tais que:</p>
<p><span class="math display">\[
\sqrt{r} = \frac{m}{n}
\]</span></p>
<p>Elevando os dois lados ao quadrado, temos:</p>
<p><span class="math display">\[
r = \frac{m^2}{n^2}
\]</span></p>
<p>Como <span class="math inline">\(m^2\)</span> e <span class="math inline">\(n^2\)</span> são inteiros, <span class="math inline">\(r\)</span> é racional.</p>
</div>
</section>
</section>
<section id="provando-se-somente-se" class="level2" data-number="1.5">
<h2 data-number="1.5" class="anchored" data-anchor-id="provando-se-somente-se"><span class="header-section-number">1.5</span> Provando “se somente se””</h2>
<p>Muitos teoremas matemáticos afirmam que duas declarações são logicamente equivalentes; ou seja, uma é válida se, e somente se, a outra também for. Aqui está um exemplo que é conhecido há milhares de anos: Dois triângulos têm os mesmos comprimentos de lados se, e somente se, dois comprimentos de lados e o ângulo entre esses lados forem os mesmos. A expressão “se, e somente se” aparece com tanta frequência que muitas vezes é abreviada como “sse”.</p>
<section id="método-1-prove-que-cada-declaração-implica-na-outra" class="level3" data-number="1.5.1">
<h3 data-number="1.5.1" class="anchored" data-anchor-id="método-1-prove-que-cada-declaração-implica-na-outra"><span class="header-section-number">1.5.1</span> Método #1: Prove que Cada Declaração Implica na Outra</h3>
<p>A declaração “P SSE Q” é equivalente a duas declarações: “P IMPLICA Q” e “Q IMPLICA P”. Então, você pode provar um “sse” provando duas implicações:</p>
<ol type="1">
<li>Escreva: “Provamos que P implica Q e vice-versa.”</li>
<li>Escreva: “Primeiro, mostramos que P implica Q.” Faça isso por um dos métodos da Seção 1.5.</li>
<li>Escreva: “Agora, mostramos que Q implica P.” Novamente, faça isso por um dos métodos da Seção 1.5.</li>
</ol>
</section>
<section id="método-2-construa-uma-cadeia-de-sse" class="level3" data-number="1.5.2">
<h3 data-number="1.5.2" class="anchored" data-anchor-id="método-2-construa-uma-cadeia-de-sse"><span class="header-section-number">1.5.2</span> Método #2: Construa uma Cadeia de SSE</h3>
<p>Para provar que P é verdadeiro se, e somente se, Q for verdadeiro:</p>
<ol type="1">
<li>Escreva: “Construímos uma cadeia de implicações se, e somente se.”</li>
<li>Prove que P é equivalente a uma segunda declaração, que é equivalente a uma terceira, e assim por diante, até que você chegue a Q.</li>
</ol>
<p>Esse método às vezes requer mais criatividade do que o primeiro, mas o resultado pode ser uma prova curta e elegante.</p>
</section>
<section id="exemplo" class="level3" data-number="1.5.3">
<h3 data-number="1.5.3" class="anchored" data-anchor-id="exemplo"><span class="header-section-number">1.5.3</span> Exemplo</h3>
<p>A <strong>desvio padrão</strong> de uma sequência de valores <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> é definida como:</p>
<p><span class="math display">\[
s = \sqrt{\frac{(x_1 - \mu)^2 + (x_2 - \mu)^2 + \dots + (x_n - \mu)^2}{n}}
\]</span></p>
<p>onde <span class="math inline">\(\mu\)</span> é a média dos valores:</p>
<p><span class="math display">\[
\mu = \frac{x_1 + x_2 + \dots + x_n}{n}
\]</span></p>
<p><strong>Teorema 1.6.1.</strong> O desvio padrão de uma sequência de valores <span class="math inline">\(x_1, x_2, \dots, x_n\)</span> é zero se, e somente se, todos os valores forem iguais à média. Por exemplo, o desvio padrão das notas de teste é zero se, e somente se, todos tiverem exatamente a média da turma.</p>
<p><strong>Prova.</strong> Construímos uma cadeia de implicações “sse”, começando com a declaração de que o desvio padrão é zero:</p>
<p><span class="math display">\[
s = \sqrt{\frac{(x_1 - \mu)^2 + (x_2 - \mu)^2 + \dots + (x_n - \mu)^2}{n}} = 0
\]</span></p>
</section>
</section>
<section id="modus-ponens" class="level2" data-number="1.6">
<h2 data-number="1.6" class="anchored" data-anchor-id="modus-ponens"><span class="header-section-number">1.6</span> Modus ponens</h2>
<p>Uma vez que provamos uma implicação</p>
<p><span class="math display">\[
P \implies Q
\]</span></p>
<p>como sendo sempre verdadeira, queremos usá-la. Logo provaremos que a implicação</p>
<blockquote class="blockquote">
<p>Se <span class="math inline">\(n\)</span> é par, então <span class="math inline">\(n^2\)</span> é par.</p>
</blockquote>
<p>é sempre verdadeira. Sabemos que não pode ser falsa, então vamos escrever as 3 linhas relevantes de sua tabela verdade e suprimir a linha correspondente à implicação ser falsa:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>Note que, se pegarmos um número como <span class="math inline">\(n = 14\)</span>, sabemos que ele é par e, portanto, a hipótese é verdadeira. Pela tabela verdade, sabemos que a conclusão também deve ser verdadeira — o número <span class="math inline">\(n^2 = 14^2\)</span> é par. Não precisamos fazer mais nada; a tabela verdade, e nossa prova, garantem que a conclusão é verdadeira.</p>
<p>De modo mais geral, se provamos que</p>
<p><span class="math display">\[
P \implies Q
\]</span></p>
<p>é sempre verdadeiro, então, se sabemos que a hipótese <span class="math inline">\(P\)</span> é verdadeira, a conclusão <span class="math inline">\(Q\)</span> também deve ser verdadeira.</p>
<div id="def-modusponens" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.2 (Modus ponens)</strong></span> A dedução:</p>
<ul>
<li><span class="math inline">\(P\)</span> implica <span class="math inline">\(Q\)</span> é verdadeiro, e</li>
<li><span class="math inline">\(P\)</span> é verdadeiro</li>
<li>logo, <span class="math inline">\(Q\)</span> deve ser verdadeiro.</li>
</ul>
<p>é chamada de <strong>modus ponens</strong>.</p>
</div>
<p>Esta dedução lógica foi formalizada pela primeira vez por Teofrasto.</p>
<p>Note que, se tivermos provado a implicação <span class="math inline">\(P \implies Q\)</span> como verdadeira, mas a hipótese <span class="math inline">\(P\)</span> for falsa, então <strong>não podemos</strong> concluir nada sobre o valor de verdade da conclusão. Quando a hipótese é falsa, o valor de verdade da conclusão não importa — a implicação ainda é verdadeira. Podemos verificar isso considerando as duas linhas relevantes da tabela verdade da implicação.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>De forma similar, se tivermos provado a implicação <span class="math inline">\(P \implies Q\)</span> como verdadeira, e tivermos provado que a conclusão <span class="math inline">\(Q\)</span> é verdadeira, então não podemos concluir nada sobre o valor de verdade da hipótese <span class="math inline">\(P\)</span>. Novamente, isso é facilmente verificado considerando as duas linhas relevantes da tabela verdade da implicação.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>No entanto, há uma outra instância na qual podemos fazer uma conclusão válida. Considere novamente a tabela verdade quando a implicação <span class="math inline">\(P \implies Q\)</span> é verdadeira, mas a conclusão <span class="math inline">\(Q\)</span> é falsa:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies Q\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>Aqui, a única possibilidade é que a hipótese deve ser falsa. Isso nos permite fazer outra dedução válida.</p>
<div id="def-modustollens" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1.3 (Modus tollens)</strong></span> A dedução:</p>
<ul>
<li><span class="math inline">\(P\)</span> implica <span class="math inline">\(Q\)</span> é verdadeira, e</li>
<li><span class="math inline">\(Q\)</span> é falso</li>
<li>logo, <span class="math inline">\(P\)</span> deve ser falso.</li>
</ul>
<p>é chamada de <strong>modus tollens</strong>.</p>
</div>
<p>Então, quando sabemos (voltando ao nosso exemplo) que:</p>
<blockquote class="blockquote">
<p>Se ele é Shakespeare, então ele está morto.</p>
</blockquote>
<p>podemos concluir que qualquer pessoa viva não é Shakespeare.</p>
<section id="afirmar-o-consequente-e-negar-o-antecedente" class="level4" data-number="1.6.0.1">
<h4 data-number="1.6.0.1" class="anchored" data-anchor-id="afirmar-o-consequente-e-negar-o-antecedente"><span class="header-section-number">1.6.0.1</span> Afirmar o consequente e negar o antecedente</h4>
<p>A má aplicação do <strong>modus ponens</strong> é uma fonte frequente de erros lógicos. Um erro muito comum é chamado de “afirmar o consequente”.</p>
</section>
<div id="wrn-errocomum1">
<section id="um-erro-lógico-comum." class="level3" data-number="1.6.1">
<h3 data-number="1.6.1" class="anchored" data-anchor-id="um-erro-lógico-comum."><span class="header-section-number">1.6.1</span> Um erro lógico comum.</h3>
<p>A falsa dedução:</p>
<ul>
<li><span class="math inline">\(P\)</span> implica <span class="math inline">\(Q\)</span> é verdadeiro, e</li>
<li><span class="math inline">\(Q\)</span> é verdadeiro,</li>
<li>e, portanto, <span class="math inline">\(P\)</span> deve ser verdadeiro.</li>
</ul>
<p>é chamada de <strong>afirmar o consequente</strong>.</p>
</section>
</div>
<blockquote class="blockquote">
<p>O fluxo de lógica está errado — verifique a tabela verdade. Além disso, a notação de seta para a implicação, <span class="math inline">\(\implies\)</span>, nos ajuda a lembrar que a verdade deve fluir da hipótese para a conclusão, e não o contrário.</p>
</blockquote>
<p>Para ver quão errado isso pode ser, considere novamente a verdadeira implicação:</p>
<ul>
<li>Se ele é Shakespeare, então ele está morto.</li>
</ul>
<p>Se afirmássemos o consequente, então qualquer homem morto deve ser Shakespeare.</p>
<p>Afirmar o consequente às vezes é usado como uma técnica retórica (especialmente por quem propaga bobagens):</p>
<blockquote class="blockquote">
<p>Se eles são Galileu, então são oprimidos. Estou sendo oprimido, logo devo ser Galileu.</p>
</blockquote>
<p>ou (quando sentindo pena de si mesmo)</p>
<blockquote class="blockquote">
<p>Se eles são grandes artistas, então são incompreendidos. Sou incompreendido, logo devo ser um grande artista.</p>
</blockquote>
<p>E a falácia da seção de comentários nas redes sociais:</p>
<blockquote class="blockquote">
<p>Se eu digo a verdade, ofendo as pessoas. Estou ofendendo, logo estou dizendo a verdade. Tenha cuidado com a afirmação do consequente — ela aparece com frequência e é sempre falaciosa. Um erro lógico muito semelhante é chamado de “negar o antecedente”.</p>
</blockquote>
<div id="wrn-errocomum2">
<section id="outro-erro-lógico-comum." class="level4" data-number="1.6.1.1">
<h4 data-number="1.6.1.1" class="anchored" data-anchor-id="outro-erro-lógico-comum."><span class="header-section-number">1.6.1.1</span> Outro erro lógico comum.</h4>
<p>A falsa dedução:</p>
<ul>
<li><span class="math inline">\(P\)</span> implica <span class="math inline">\(Q\)</span> é verdadeiro, e</li>
<li><span class="math inline">\(P\)</span> é falso,</li>
<li>e, portanto, <span class="math inline">\(Q\)</span> deve ser falso.</li>
</ul>
</section>
</div>
<p>é chamada de <strong>negar o antecedente</strong> e é uma má aplicação do <strong>modus tollens</strong>.</p>
<p>Aqui estão alguns exemplos:</p>
<blockquote class="blockquote">
<p>Se eu fui a Toronto, então visitei o Canadá. Eu não fui a Toronto, então não visitei o Canadá.</p>
</blockquote>
<blockquote class="blockquote">
<p>Se ele é Shakespeare então ele está morto. Abraham Linconl não é Shakespeare, então ele deve estar vivo.</p>
</blockquote>
<blockquote class="blockquote">
<p>Se tem gosto ruim então deve ser saudável. Isso tem gosto bom, então não deve ser saudável.</p>
</blockquote>
<section id="encadeando-implicações" class="level3" data-number="1.6.2">
<h3 data-number="1.6.2" class="anchored" data-anchor-id="encadeando-implicações"><span class="header-section-number">1.6.2</span> Encadeando implicações</h3>
<p>Quando construímos uma prova de que <span class="math inline">\(P \implies Q\)</span> é verdadeira, não fazemos isso de uma só vez. Em vez disso, dividimos em uma sequência de implicações menores e mais fáceis, que podemos encadear. Para ver como isso funciona, considere o seguinte:</p>
<section id="resultado" class="level4" data-number="1.6.2.1">
<h4 data-number="1.6.2.1" class="anchored" data-anchor-id="resultado"><span class="header-section-number">1.6.2.1</span> Resultado</h4>
<p>Seja <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span> e <span class="math inline">\(R\)</span> declarações. Então, a seguinte afirmação é sempre verdadeira:</p>
<p><span class="math display">\[
\Big( (P \implies R) \land (R \implies Q) \Big) \implies (P \implies Q)
\]</span></p>
<p>Este resultado é um exemplo de uma tautologia, uma afirmação que é sempre verdadeira. Voltaremos às tautologias mais tarde no texto. Para mostrar que é sempre verdadeira, poderíamos construir a tabela verdade ou usar algum raciocínio. Ambos os métodos são provas, mas não seremos tão formais até o próximo capítulo. A tabela verdade não é difícil de construir, mas um pouco tediosa; como cada uma de <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span> pode ser verdadeira ou falsa, há <span class="math inline">\(2^3 = 8\)</span> linhas a considerar:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 7%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><span class="math inline">\(P\)</span></th>
<th style="text-align: center;"><span class="math inline">\(Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies R\)</span></th>
<th style="text-align: center;"><span class="math inline">\(R \implies Q\)</span></th>
<th style="text-align: center;"><span class="math inline">\(P \implies Q\)</span></th>
<th style="text-align: center;">A afirmação</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="odd">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
<tr class="even">
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">F</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">T</td>
</tr>
</tbody>
</table>
<p>A tabela acima é uma maneira perfeitamente razoável de mostrar que a afirmação é sempre verdadeira. No entanto, podemos fazer o mesmo apenas com um pouco de raciocínio; isso também melhora nossa compreensão da afirmação. Apresentaremos o argumento em forma de pontos:</p>
<ul>
<li><p>A declaração é uma implicação com a hipótese <span class="math inline">\(((P \implies R) \land (R \implies Q))\)</span> e a conclusão <span class="math inline">\((P \implies Q)\)</span>. Uma implicação é falsa quando a hipótese é verdadeira, mas a conclusão é falsa; caso contrário, a implicação é verdadeira.</p></li>
<li><p>Como a conclusão, <span class="math inline">\((P \implies Q)\)</span>, é uma implicação, só pode ser falsa quando sua hipótese é verdadeira e sua conclusão é falsa. Portanto, devemos ter que <span class="math inline">\(P\)</span> é verdadeiro, mas <span class="math inline">\(Q\)</span> é falso.</p></li>
<li><p>Para que a hipótese seja verdadeira, ambas as implicações, <span class="math inline">\((P \implies R)\)</span> e <span class="math inline">\((R \implies Q)\)</span>, devem ser verdadeiras (já que uma conjunção de duas afirmações só é verdadeira quando ambas são verdadeiras).</p>
<ul>
<li><p>Como <span class="math inline">\(P\)</span> é verdadeiro e exigimos que <span class="math inline">\((P \implies R)\)</span> seja verdadeiro, <span class="math inline">\(R\)</span> deve ser verdadeiro.</p></li>
<li><p>Como <span class="math inline">\(Q\)</span> é falso e exigimos que <span class="math inline">\((R \implies Q)\)</span> seja verdadeiro, <span class="math inline">\(R\)</span> deve ser falso.</p></li>
</ul></li>
</ul>
<p>Mas, como <span class="math inline">\(R\)</span> é uma afirmação, ela não pode ser verdadeira e falsa ao mesmo tempo.</p>
<ul>
<li>Portanto, não há como fazer a afirmação ser falsa. Como nunca é falsa, ela deve ser sempre verdadeira.</li>
</ul>
<p>Então, voltando à declaração <span class="math inline">\(P \implies Q\)</span>. Gostaríamos de mostrar que é sempre verdadeira, mas não podemos fazê-lo de uma só vez. Em vez disso, assumimos que podemos dar dois passos menores e provar que as duas implicações <span class="math inline">\((P \implies R)\)</span> e <span class="math inline">\((R \implies Q)\)</span> são sempre verdadeiras. A conjunção das duas implicações, <span class="math inline">\((P \implies R) \land (R \implies Q)\)</span>, também é verdadeira e é exatamente a hipótese do <strong>Resultado 2.5.5</strong>. Como a implicação no <strong>Resultado 2.5.5</strong> é sempre verdadeira e sua hipótese é verdadeira — <strong>modus ponens</strong> — sua conclusão deve ser verdadeira.</p>
<p>Portanto, enquanto poderíamos tentar provar <span class="math inline">\((P \implies Q)\)</span> de uma só vez, é suficiente provar que é verdadeira em dois passos menores <span class="math inline">\((P \implies R)\)</span> e <span class="math inline">\((R \implies Q)\)</span>. Mais genericamente, ao provarmos <span class="math inline">\((P \implies Q)\)</span>, provaremos uma sequência de implicações:</p>
<p><span class="math display">\[
P \implies P_1
\]</span></p>
<p><span class="math display">\[
P_1 \implies P_2 \
\]</span></p>
<p><span class="math display">\[
P_2 \implies P_3 \
\]</span></p>
<p><span class="math display">\[
\dots \
\]</span></p>
<p><span class="math display">\[
P_n \implies Q
\]</span></p>
<p>onde cada uma dessas implicações intermediárias é mais fácil de provar.</p>
<p>Uma vez feito isso, considere o que acontece se <span class="math inline">\(P\)</span> for verdadeiro ou falso:</p>
<blockquote class="blockquote">
<p><strong><span class="math inline">\(P\)</span> é verdadeiro:</strong> Se <span class="math inline">\(P\)</span> é verdadeiro, a primeira implicação nos diz que <span class="math inline">\(P_1\)</span> é verdadeiro (<strong>modus ponens</strong>). Então, como <span class="math inline">\(P_1\)</span> é verdadeiro, a próxima implicação nos diz que <span class="math inline">\(P_2\)</span> é verdadeiro (novamente <strong>modus ponens</strong>). Como <span class="math inline">\(P_2\)</span> é verdadeiro, <span class="math inline">\(P_3\)</span> é verdadeiro, <span class="math inline">\(P_4\)</span> é verdadeiro, e assim por diante, até que possamos concluir que <span class="math inline">\(Q\)</span> é verdadeiro. Como <span class="math inline">\(P\)</span> é verdadeiro e <span class="math inline">\(Q\)</span> é verdadeiro, a implicação <span class="math inline">\(P \implies Q\)</span> é verdadeira.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong><span class="math inline">\(P\)</span> é falso:</strong> Por outro lado, se <span class="math inline">\(P\)</span> for falso, sabemos, apenas olhando a tabela verdade da implicação, que a implicação <span class="math inline">\(P \implies Q\)</span> é verdadeira.</p>
</blockquote>
<p>Note que, quando <span class="math inline">\(P\)</span> é falso, o fato de que <span class="math inline">\((P \implies Q)\)</span> é verdadeiro é imediato e simplesmente depende da tabela verdade da implicação; não precisamos fazer nenhum trabalho ou raciocínio. Por outro lado, quando <span class="math inline">\(P\)</span> é verdadeiro, precisamos trabalhar para mostrar que <span class="math inline">\((P \implies Q)\)</span> é verdadeira. Por essa razão, quase todas as nossas provas começarão com a suposição de que <span class="math inline">\(P\)</span> é verdadeiro. Geralmente deixamos o caso “P é falso” implícito, assumindo que nosso leitor conhece as tabelas verdade.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./index.html" class="pagination-link" aria-label="Início">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Início</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./summary.html" class="pagination-link" aria-label="Summary">
        <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Summary</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>